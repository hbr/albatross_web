\section{Predicate Logic}

In this chapter we proof some basic facts of predicate logic using only the
modules \lstinline!boolean_logic! and \lstinline!predicate! of the base
library. Note that the modules \lstinline!boolean! and \lstinline!any! of the
base library are used implicitely.

\begin{lstlisting}
    -- file: predicate_logic_playground.al

    use
        alba.base.boolean_logic
        alba.base.predicate
    end
\end{lstlisting}

Many of the proofs below can be found in the module
\lstinline!alba.base.predicate_logic!. We use these proofs to demonstrate some
important concepts of the Albatross language and its proof engine.



\subsection{Some Simple Theorems}

Recall from the chapter \ref{module-predicate} that \lstinline!0! represents
the empty set or the unsatisfiable predicate and \lstinline!1! represents the
universal set. Evidently the empty set is a subset of any other set and the
universal set is a superset of any other set. I.e. we want to be able to prove

\begin{lstlisting}
    0 <= p

    p <= 1
\end{lstlisting}
for any predicate \lstinline!p!. If we enter the assertion into our playground
module we get an assertions which is proved by the proof engine automatically.

\begin{lstlisting}
    all(p:G?)
        ensure
            0 <= p
            p <= 1
        end
\end{lstlisting}

What happens under the hood? Let us look at the first assertion and display
what the proof engine generates.

\begin{lstlisting}
    all(p:G?)
        proof -- generated by the proof engine
            all(x)   -- entering and deduction rule
                require
                    x in 0
                proof
                    x in {x: false}      -- '0' expanded
                    false                -- beta reduction
                    all(a) a             -- ex falso quodlibet
                ensure
                    x in p               -- trivially valid
                end

            all(x) x in 0  ==>  x in p   -- '<=' expanded
        ensure
            0 <= p
        end
\end{lstlisting}
We have to read this proof first bottoms up. The proof engine looks at the
target \lstinline!0 <= p! and expands the definition. The new goal is a
universally quantified expression. This is proved by entering it. Entering a
universally quantified goal means to generate a new context within which all
bound variables are visible. The internal goal of the universally quantified
expression is an implication, therefore the deduction rule can be applied
shifting the antecedent into the context.

Now the proof engine can apply forward reasoning to the assumption
\lstinline!x in 0!. The \lstinline!in! operator cannot be expanded, because no
definition is available. But the right operand \lstinline!0! has a defintion
which can be unfolded resulting in \lstinline!x in {x:false}!. Then beta
reduction can be applied to this expression putting \lstinline!false! into the
context. Now the proof engine specializes the law {\em ex falso quodlibet}
from the module \lstinline!boolean_logic! putting \lstinline!all(a) a! into
the context. Having this all goals can be proved immediately.

At this point it might be interesting to understand the precise rules which
govern function expansion and beta reduction.

\begin{enumerate}
\item No functions are expanded in universally quantified expressions,
  implications and conjunctions.
\item If the expression has at the toplevel a function whose definition is
  available it expands the definition (the function \lstinline!<=! in the
  above example).
\item If the expression can be beta reduces at the toplevel then beta
  reduction is done.
\item If the expression has at the top a function with no definition available
  all definitions below are expanded recursively.
\end{enumerate}

The expression \lstinline!x in 0! is expanded to \lstinline!x in {x:false}!
because no definition is available for the \lstinline!in! operator and the
constant \lstinline!0! has a definition. If there were available a definition
for the \lstinline!in! operator then the subterm \lstinline!0! would not be
expanded.

The same applies to beta reductions. If a beta reduction is possible at the
top then no definitions nor beta reductions in inner subterms are applied.

Exercise: Explain how the proof engine proves the assertions
\begin{lstlisting}
    p <= 1
    p * (-p) = 0
    p + (-p) = 1
\end{lstlisting}


\subsection{Singleton Sets}

A singleton set is a set with one element e.g. \lstinline!{a}!. Note that
\lstinline!{a}! is just a shorthand for \lstinline!singleton(a)! which has the
definition \lstinline!{x: x=a}!.

A singleton set has one element and therefore cannot be empty. We should be
able to prove
\begin{lstlisting}
    {a} /= 0
\end{lstlisting}
This goal is expanded to \lstinline!{a} = 0 ==> false!, the antecedent is
shifted into the context and \lstinline!false! is used as a new goal. With the
antecedent in the context the proof engine starts forward resoning by entering
the following expressions into the context:
\begin{lstlisting}
     {a} = 0
     {a} <= 0
     0   <= {a}
     all(x) x in {a} ==> x in 0
     all(x) x in 0   ==> x in {a}
\end{lstlisting}
Now no rule can be applied for backward reasoning and the proof engine cannot
continue to prove the goal \lstinline!false!.

We need to give the proof engine a hint on how to continue. If we look the
result of forward reasoning we discover that \lstinline!x in 0! for any
\lstinline!x! would do the job. \lstinline!0! could be expanded and
betareduction would resolve the goal. I.e. we need some \lstinline!x! which is
in \lstinline!{a}!. Clearly \lstinline!a! is in \lstinline!{a}!. Now we have
the missing link and can formulate a complete proof.

\begin{lstlisting}
    all(a:G)
        proof
            a in 0  ==>  false
        ensure
            {a} /= 0
        end
\end{lstlisting}



\subsection{Leibniz Equality and Term Rewriting}

The module \lstinline!predicate! of the base library asserts the Leibniz rule
of equality.

\begin{lstlisting}
    -- from the module 'predicate'
    all(a,b:G, p:G?)
        ensure
            a = b  ==>  p(a)  ==>  p(b)
        end
\end{lstlisting}
This rule states that equal objects cannot be distinguished by any property,
i.e. if \lstinline!a! has a certain property then \lstinline!b! has it as
well.

As already explained in the chapter \ref{module-predicate} we can use the
Leibniz rule to do term rewritings. Here we use the Leibniz rule to prove the
symmetry and transitivity of equality i.e. we want to prove the laws
\begin{lstlisting}
    a = b  ==>  b = a               -- symmetric

    a = b  ==>  b = c  ==>  a = c   -- transitive
\end{lstlisting}

Let's look first at symmetry. The proof engine applies the deduction rule and
shifts \lstinline!a = b! into the context. Having this it can partially
specialize the Leibniz rule to get \lstinline!all(p) p(a) ==> p(b)! into the
context. No more forward nor backward steps are possible and the proof engine
cannot continue.

The goal is \lstinline!b = a!. If we want to explore the Leibniz rule we have
to express this a property applied to \lstinline!b!. The expression
\lstinline!b in {a}! will do the job because this expression expanded yields
the goal \lstinline!b = a!. The proof engine can proof \lstinline!b in {a}! by
using the partially specialized Leibniz rule as a backward rule.

\begin{lstlisting}
    all(a,b:G)
        require
            a = b
        proof
            b in {a}
        ensure
            b = a
        end
\end{lstlisting}

In proving transitivity the proof engine shifts the two antecedents into the
context and forward closes it by doing partial specialization of the Leibniz
rule. The context for the goal \lstinline!a = c! looks like
\begin{lstlisting}
    a = b
    b = c
    all(p) p(a) ==> p(b)
    all(p) p(b) ==> p(c)
\end{lstlisting}
Because we have already proved the symmetry of equality the proof engine can
do some backward reasoning and try to prove \lstinline!c = a! instead of
\lstinline!a = c!. We can express the latter by the equivalent expression
\lstinline!c in {a}!. This expression can be proved by the engine by using the
partially specialized Leibniz rules and doing backward reasoning reaching at
\lstinline!a in {a}! which is proved trivially.

\begin{lstlisting}
    all(a,b,c:G)
        require
            a = b
            b = c
        proof
            c in {a}
        ensure
            a = c
        end
\end{lstlisting}

Having proved the transitivity of an operator the proof engine is able to follow
transitivity chains. The following proof discharges automatically.

\begin{lstlisting}
    all(a,b,c,d,e:G)
        require
            a = b
            b = c
            c = d
            d = e
        ensure
            a = e
        end
\end{lstlisting}



\subsection{Existential Quantification}

An existential quantified expression in Albatross looks like
\begin{lstlisting}
    some(x,y,...)  expression
\end{lstlisting}
where the expression contains the variables \lstinline!x,y,...!. The proof
engine of Albatross has two hardwired procedures to handle existentially
quantified expressions.

Introduction rule: If the goal of a proof is an existentially quantified
expression it looks for witnesses i.e. it tries to find expressions in the
context with specific values for the variables so that the expression with the
specific values is valid. If there are witnesses then the existentially
quantified expression is proved.


Elimination rule: Whenever an existentially quantified expression is entered
into the context, the proof engine enters the following assertions into the
context.
\begin{lstlisting}
    all(c) (all(x,y,...) expression ==> c) ==> c
\end{lstlisting}

The introduction rule is immediately evident. The elimination rule mimics the
following mathematical proof technique:
\begin{quote}
  We know that there is some $x$ which satisfies $p$. Let $a$ be an arbitrary value
  satisfying $p$. From $a$ satisfying $p$ we conclude $c$. Therefore $c$ is valid.
\end{quote}

We use these laws to prove that every set which has elements is nonempty and
every nonempty set has elements i.e.
\begin{lstlisting}
    some(x) x in p  ==>  p /= 0

    p /= 0  ==>  some(x) x in p
\end{lstlisting}
For the first one the proof engine ends up in the following context/goal pair
and then gets stuck.
\begin{lstlisting}
    some(x) x in p

    all(c) (all(x) x in p ==> c) ==> c

    p = 0                        -- (1)

    p <= 0

    all(x) x in p  ==> x in 0    -- (2)
    ...
    ==================================
    false
\end{lstlisting}
Now we have to give the proof engine a hint how to substitute \lstinline!c! so
that \lstinline!all(x) x in p ==> c! can be proved in the context and
\lstinline!c! implies a contradiction within the context. We note that we can
substitute anything for \lstinline!c! because (2) guarantees that with
\lstinline!x in p! in the context we get an immediate contradiction and can
prove anything. A good choice for \lstinline!c! is \lstinline!p /= 0! because
together with (1) we get the needed contradiction to prove
\lstinline!false!. The complete proof:

\begin{lstlisting}  
    all(p:G?)
        require
            some(x) x in p
        proof
            all(x) x in p ==> p /= 0
        ensure
            p /= 0
        end
\end{lstlisting}

Now the other direction \lstinline!p /= 0! \lstinline!==>!
\lstinline!some(x) x in p!. With this goal the proof engine becomes stuck very
fast. It just enriches the context by expanding \lstinline!/=! and then
\lstinline!not! and finds nothing more to continue. We cannot find any way to
generate a witness for the existentially quantified expression. If all else
fail we can try a proof by contradiction i.e. we add the negated goal to the
context and try to derive \lstinline!false! from it. Lets see the steps the
proof engine would do.
\begin{lstlisting}
    all(p:G?)
        require
            p /= 0
            not some(x) x in p
        proof
            p = 0  ==>  false
            (some(x) x in p)  ==> false

            all(x)
                require
                    x in p
                proof
                    some(x) x in p
                    false
                ensure
                    x in 0
                end
            p <= 0
            p = 0
        ensure
            false
        end
\end{lstlisting}
First it does forward reasoning on the two assumptions and gets two
implications into the context which have \lstinline!false! as a target. Then
uses the first in a backward reasoning step with the new goal
\lstinline!p = 0!. For this goal in has to prove \lstinline!all(x) x in p!
\lstinline!==>! \lstinline!x in 0!. It enters it and realizes that it
needs a further contradiction to prove it. Then it uses the second implication
and gets the new goal \lstinline!some(x) x in p!. This goal can be resolved
immediately because there is a witness in the context.

The only thing needed by the proof engine is a trigger to start a proof by
contradiction. Therefore the following proof is complete.

\begin{lstlisting}
    all(p:G?)
        require
            p /= 0
        proof
            not not some(x) x in p
        ensure
            some(x) x in p
        end
\end{lstlisting}


%%% Local Variables: 
%%% mode: latex
%%% case-fold-search: nil
%%% TeX-master: "albatross"
%%% End: 
